<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AetherTouch - Interactive 3D Particles</title>
    <style>
        :root {
            --primary-color: #00f3ff;
            --bg-color: #050505;
            --panel-bg: rgba(20, 20, 30, 0.7);
            --text-color: #ffffff;
            --accent-color: #bc13fe;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-color);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Overlay */
        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            padding: 20px;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            transition: opacity 0.3s ease;
        }

        h1 {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            margin-top: 0;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
        }

        p.status {
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #ff3b3b;
            transition: background-color 0.3s;
        }

        .status-dot.active {
            background-color: #00ff88;
        }

        .controls-section {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        /* Buttons */
        .btn-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        button {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        button.active {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            border-color: transparent;
            color: #000;
            font-weight: bold;
        }

        /* Color Picker */
        input[type="color"] {
            -webkit-appearance: none;
            appearance: none;
            border: none;
            width: 100%;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
            padding: 0;
            overflow: hidden;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 8px;
        }

        /* Webcam feedback (hidden but useful for debugging if needed, currently set to display none) */
        /* Webcam feedback - Integrated into UI */
        #video-feed {
            width: 100%;
            height: auto;
            border-radius: 8px;
            opacity: 0.8;
            transform: scaleX(-1);
            /* Mirror */
            display: block;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1rem;
            background: #000;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>

    <div class="loading-overlay" id="loader">
        <div class="spinner"></div>
        <p style="margin-top: 1rem;">Loading AI Models...</p>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-container">
        <h1>AetherTouch</h1>

        <!-- Webcam Feed (HUD Style) -->
        <video id="video-feed" playsinline></video>

        <p class="status">
            <span class="status-dot" id="status-dot"></span>
            <span id="status-text">Detecting Hands...</span>
        </p>
        <p class="status" style="margin-top: -0.5rem;">
            <span class="status-dot" id="pinch-dot"></span>
            <span id="pinch-text">Pinch: Inactive</span>
        </p>
        <p class="status" style="margin-top: -0.5rem;">
            <span class="status-dot" id="zoom-dot"></span>
            <span id="zoom-text">Zoom: Use both hands</span>
        </p>

        <div class="controls-section">
            <label>Templates</label>
            <div class="btn-grid">
                <button class="tpl-btn active" data-shape="sphere">Sphere</button>
                <button class="tpl-btn" data-shape="heart">Heart</button>
                <button class="tpl-btn" data-shape="flower">Flower</button>
                <button class="tpl-btn" data-shape="saturn">Saturn</button>
                <button class="tpl-btn" data-shape="buddha">Buddha</button>
                <button class="tpl-btn" data-shape="fireworks">Fireworks</button>
            </div>
        </div>

        <div class="controls-section">
            <label>Particle Color</label>
            <input type="color" id="color-picker" value="#00f3ff">
        </div>

        <p style="font-size: 0.7rem; color: #666; text-align: center; margin-top: 1rem;">
            Created by <a href="https://www.linkedin.com/in/gtm-engineer-mathew/" target="_blank"
                style="color: var(--primary-color); text-decoration: none;">Mathew Joseph</a>
        </p>
    </div>

    <script>
        // --- One Euro Filter (Industry-standard smoothing for gesture tracking) ---
        // Reduces jitter while maintaining responsiveness
        class OneEuroFilter {
            constructor(minCutoff = 1.0, beta = 0.007, dCutoff = 1.0) {
                this.minCutoff = minCutoff;
                this.beta = beta;
                this.dCutoff = dCutoff;
                this.x = null;
                this.dx = 0;
                this.lastTime = null;
            }

            alpha(cutoff, dt) {
                const tau = 1.0 / (2 * Math.PI * cutoff);
                return 1.0 / (1.0 + tau / dt);
            }

            filter(x, timestamp = null) {
                if (this.lastTime === null) {
                    this.x = x;
                    this.lastTime = timestamp || performance.now() / 1000;
                    return x;
                }

                const now = timestamp || performance.now() / 1000;
                const dt = Math.max(now - this.lastTime, 0.001);
                this.lastTime = now;

                const dx = (x - this.x) / dt;
                const alphaDx = this.alpha(this.dCutoff, dt);
                this.dx = alphaDx * dx + (1 - alphaDx) * this.dx;

                const cutoff = this.minCutoff + this.beta * Math.abs(this.dx);
                const alphaX = this.alpha(cutoff, dt);
                this.x = alphaX * x + (1 - alphaX) * this.x;

                return this.x;
            }

            reset() {
                this.x = null;
                this.dx = 0;
                this.lastTime = null;
            }
        }

        // --- Gesture State Debouncer ---
        // Prevents rapid state transitions that cause glitches
        class GestureDebouncer {
            constructor(enterDelay = 50, exitDelay = 100) {
                this.enterDelay = enterDelay;
                this.exitDelay = exitDelay;
                this.state = false;
                this.pendingState = false;
                this.lastChangeTime = 0;
            }

            update(rawState) {
                const now = performance.now();

                if (rawState !== this.pendingState) {
                    this.pendingState = rawState;
                    this.lastChangeTime = now;
                }

                const delay = this.pendingState ? this.enterDelay : this.exitDelay;

                if (this.pendingState !== this.state && (now - this.lastChangeTime) >= delay) {
                    this.state = this.pendingState;
                }

                return this.state;
            }

            reset() {
                this.state = false;
                this.pendingState = false;
                this.lastChangeTime = 0;
            }
        }

        // --- Configuration & State ---
        const config = {
            particleCount: 5000,
            baseSize: 0.15,
            lerpSpeed: 0.05,
            handInteractionStrength: 2.0,
            // Pinch detection with hysteresis (different thresholds for enter/exit)
            pinchEnterThreshold: 0.65,
            pinchExitThreshold: 0.50,
            // Gesture timing
            gestureEnterDelay: 60,   // ms to wait before activating gesture
            gestureExitDelay: 120    // ms to wait before deactivating gesture
        };

        // --- Filters for smooth hand tracking ---
        const filters = {
            hand1: {
                grabX: new OneEuroFilter(1.0, 0.01),
                grabY: new OneEuroFilter(1.0, 0.01),
                palmX: new OneEuroFilter(1.5, 0.005),
                palmY: new OneEuroFilter(1.5, 0.005)
            },
            hand2: {
                palmX: new OneEuroFilter(1.5, 0.005),
                palmY: new OneEuroFilter(1.5, 0.005)
            }
        };

        // --- Gesture Debouncers ---
        const debouncers = {
            pinch: new GestureDebouncer(config.gestureEnterDelay, config.gestureExitDelay),
            pinch2: new GestureDebouncer(config.gestureEnterDelay, config.gestureExitDelay),
            steering: new GestureDebouncer(100, 150),
            doublePinch: new GestureDebouncer(80, 100)
        };

        const state = {
            currentShape: 'sphere',
            handDetected: false,
            twoHandsDetected: false,
            tension: 0, // 0 to 1 (relaxed to clenched)
            pinchStrength: 0, // 0 to 1 (open to pinched)
            isPinching: false,
            // Grab-and-drag state
            isGrabbing: false,
            grabStartHandPos: { x: 0, y: 0 },
            grabStartObjectPos: { x: 0, y: 0, z: 0 },
            grabStartHandAngle: 0,
            grabStartObjectRotation: { x: 0, y: 0, z: 0 },
            currentHandPos: { x: 0, y: 0 },
            objectOffset: { x: 0, y: 0, z: 0 },
            objectRotation: { x: 0, y: 0, z: 0 }, // Accumulated rotation
            // Hand identity tracking (prevents swap issues)
            primaryHandLabel: null, // 'Left' or 'Right' - which hand is controlling
            // Elastic Zoom State
            twoHandDistance: 0,
            neutralDistance: null,    // The reference distance for "Zero speed"
            twoHandScale: 1.0,        // The persisted scale value
            isDoublePinching: false,  // Active trigger for Elastic Zoom

            twoHandStartAngle: null,   // For Steering - null indicates not yet initialized
            twoHandStartObjRotation: 0, // For Steering Z
            isSteering: false,         // New Flag for Closed-Hand Steering
            hand2PinchStrength: 0,     // Smoothed pinch strength for hand 2
            isZooming: false,          // Flag for zoom state
            lastScaleFactor: 1.0,      // For smooth scale transitions
            targetColor: new THREE.Color(0x00f3ff),
            baseColor: new THREE.Color(0x00f3ff),
            time: 0,
            // Momentum/Inertia state
            velocity: { x: 0, y: 0 },
            angularVelocity: 0,
            lastGrabPos: { x: 0, y: 0 },
            lastGrabAngle: 0,
            momentumActive: false
        };

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;
        camera.position.y = 2;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // --- Particle System ---
        // We'll use BufferGeometry for performance
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(config.particleCount * 3);
        const targetPositions = new Float32Array(config.particleCount * 3); // Where particles want to go
        const originalPositions = new Float32Array(config.particleCount * 3); // Base for shapes

        // Initialize with random positions
        for (let i = 0; i < config.particleCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 50;
            targetPositions[i] = positions[i];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Create a custom material or use PointsMaterial
        // Using a texture sprite for particles makes them look nicer
        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
        const material = new THREE.PointsMaterial({
            size: config.baseSize,
            color: state.targetColor,
            map: sprite,
            alphaTest: 0.5,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Shape Generators ---
        // Helper to set a point in the target array
        function setTarget(i, x, y, z) {
            targetPositions[i * 3] = x;
            targetPositions[i * 3 + 1] = y;
            targetPositions[i * 3 + 2] = z;
        }

        const shapes = {
            sphere: () => {
                const r = 6;
                for (let i = 0; i < config.particleCount; i++) {
                    const phi = Math.acos(-1 + (2 * i) / config.particleCount);
                    const theta = Math.sqrt(config.particleCount * Math.PI) * phi;

                    const x = r * Math.cos(theta) * Math.sin(phi);
                    const y = r * Math.sin(theta) * Math.sin(phi);
                    const z = r * Math.cos(phi);
                    setTarget(i, x, y, z);
                }
            },
            heart: () => {
                // Parametric heart
                // x = 16sin^3(t)
                // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                // z = varied depth
                const scale = 0.35;
                for (let i = 0; i < config.particleCount; i++) {
                    const t = Math.random() * Math.PI * 2;
                    // Spread points somewhat randomly but adhering to volume
                    const r = Math.random(); // Variance for filling inside

                    // Simple outline
                    let x = 16 * Math.pow(Math.sin(t), 3);
                    let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    let z = (Math.random() - 0.5) * 4; // Thickness

                    // Randomize slightly to fill volume
                    const v = 1 - Math.random() * 0.2;
                    x *= v; y *= v;

                    setTarget(i, x * scale, y * scale + 2, z * scale);
                }
            },
            flower: () => {
                // Rose curve (polar) r = cos(k*theta)
                const k = 4; // 4 petals
                const scale = 4;
                for (let i = 0; i < config.particleCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const r_curve = Math.cos(k * theta);

                    // Add thickness and layers
                    const r = (r_curve + 0.2) * scale * Math.random();

                    const x = r * Math.cos(theta);
                    const y = r * Math.sin(theta);
                    const z = (Math.random() - 0.5) * (2 - r / scale); // Thicker center

                    setTarget(i, x, y + 2, z);
                }
            },
            saturn: () => {
                const planetRadius = 3.5;
                const ringInner = 4.5;
                const ringOuter = 8;

                for (let i = 0; i < config.particleCount; i++) {
                    if (i < config.particleCount * 0.4) {
                        // Planet body (Sphere)
                        const phi = Math.acos(-1 + (2 * i) / (config.particleCount * 0.4));
                        const theta = Math.sqrt(config.particleCount * Math.PI) * phi;
                        const x = planetRadius * Math.cos(theta) * Math.sin(phi);
                        const y = planetRadius * Math.sin(theta) * Math.sin(phi);
                        const z = planetRadius * Math.cos(phi);
                        setTarget(i, x, y, z);
                    } else {
                        // Rings (Disc)
                        const angle = Math.random() * Math.PI * 2;
                        const dist = ringInner + Math.random() * (ringOuter - ringInner);
                        const x = dist * Math.cos(angle);
                        const z = dist * Math.sin(angle);
                        const y = (Math.random() - 0.5) * 0.2; // Thin ring

                        // Tilt the ring
                        const tilt = Math.PI / 6;
                        const yt = y * Math.cos(tilt) - x * Math.sin(tilt);
                        const xt = y * Math.sin(tilt) + x * Math.cos(tilt);

                        setTarget(i, xt, yt, z);
                    }
                }
            },
            buddha: () => {
                // Simplified Meditating Figure (Solid Geometry Construction)
                // Head (sphere), Body (Ellipsoid), Legs (Torus segment/Cylinders)
                const headR = 1.5;
                const bodyR = 2.5;

                for (let i = 0; i < config.particleCount; i++) {
                    const r = Math.random();
                    // Distribute points: 20% Head, 40% Body, 40% Legs/Base

                    if (r < 0.2) {
                        // Head
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        const rad = headR;
                        const x = rad * Math.sin(phi) * Math.cos(theta);
                        const y = rad * Math.sin(phi) * Math.sin(theta) + 3.5; // Offset up
                        const z = rad * Math.cos(phi);
                        setTarget(i, x, y, z);
                    } else if (r < 0.6) {
                        // Body
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        const x = bodyR * 0.9 * Math.sin(phi) * Math.cos(theta);
                        const y = bodyR * 1.2 * Math.sin(phi) * Math.sin(theta); // Elongated Y
                        const z = bodyR * 0.8 * Math.cos(phi);
                        setTarget(i, x, y, z);
                    } else {
                        // Legs/Base (Wide flatten sphere/torus approx)
                        const angle = Math.random() * Math.PI * 2; // -PI to PI
                        // We want a semi-circle loop for crossed legs
                        const rad = 3.5 + Math.random() * 0.5;
                        const x = rad * Math.cos(angle);
                        const y = -2.0 + (Math.random() * 1.5);
                        const z = rad * Math.sin(angle) * 0.6; // Flattened depth

                        // Cut off back to make it look like knees forward? 
                        // Lets just make a wide base ellipsoid
                        setTarget(i, x, y, z);
                    }
                }
            },
            fireworks: () => {
                // Burst from center
                for (let i = 0; i < config.particleCount; i++) {
                    // Random direction
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    // Random radius mostly at edge
                    const r = 2 + Math.random() * 8;

                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.sin(phi) * Math.sin(theta);
                    const z = r * Math.cos(phi);
                    setTarget(i, x, y, z);
                }
            }
        };

        // Initialize default shape
        shapes[state.currentShape]();

        // --- Interaction & Event Listeners ---
        function switchShape(shapeName) {
            if (shapes[shapeName]) {
                state.currentShape = shapeName;
                shapes[shapeName]();

                // Update UI buttons
                document.querySelectorAll('.tpl-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.shape === shapeName);
                });
            }
        }

        // Click handlers for templates
        document.querySelectorAll('.tpl-btn').forEach(btn => {
            btn.addEventListener('click', () => switchShape(btn.dataset.shape));
        });

        // Color picker
        const colorPicker = document.getElementById('color-picker');
        colorPicker.addEventListener('input', (e) => {
            state.targetColor.set(e.target.value);
            state.baseColor.set(e.target.value);
            material.color.set(state.targetColor);
        });

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Hand Tracking Setup (MediaPipe) ---
        const videoElement = document.getElementById('video-feed');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');

        function onResults(results) {
            // Hide loader on first result
            document.getElementById('loader').classList.add('hidden');

            // Cache UI elements (avoid repeated DOM queries)
            const pinchDot = document.getElementById('pinch-dot');
            const pinchText = document.getElementById('pinch-text');
            const zoomDot = document.getElementById('zoom-dot');
            const zoomText = document.getElementById('zoom-text');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handDetected = true;
                statusDot.classList.add('active');
                statusText.innerText = `Hands Detected: ${results.multiHandLandmarks.length}`;

                // --- HAND IDENTITY TRACKING ---
                // Use handedness to maintain consistent hand identity and prevent swap issues
                let primaryHandIndex = 0;
                if (results.multiHandedness && results.multiHandedness.length > 0) {
                    const currentLabel = results.multiHandedness[0].label;

                    // If we have a locked primary hand, find it
                    if (state.primaryHandLabel !== null) {
                        for (let i = 0; i < results.multiHandedness.length; i++) {
                            if (results.multiHandedness[i].label === state.primaryHandLabel) {
                                primaryHandIndex = i;
                                break;
                            }
                        }
                    } else if (state.isGrabbing || state.isPinching) {
                        // Lock to current hand when grabbing starts
                        state.primaryHandLabel = currentLabel;
                    }
                }

                const landmarks = results.multiHandLandmarks[primaryHandIndex];
                const wrist = landmarks[0];
                const tips = [4, 8, 12, 16, 20];

                // Calculate Tension
                let totalDist = 0;
                tips.forEach(idx => {
                    const tip = landmarks[idx];
                    const d = Math.sqrt(
                        Math.pow(tip.x - wrist.x, 2) +
                        Math.pow(tip.y - wrist.y, 2)
                    );
                    totalDist += d;
                });

                const avgDist = totalDist / tips.length;
                const minC = 0.12;
                const maxC = 0.35;
                const normalized = (avgDist - minC) / (maxC - minC);
                const tension = 1 - Math.max(0, Math.min(1, normalized));
                state.tension = state.tension * 0.92 + tension * 0.08;

                // --- Pinch Detection with Hysteresis ---
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                const pinchMin = 0.04;
                const pinchMax = 0.12;
                const pinchNorm = (pinchDist - pinchMin) / (pinchMax - pinchMin);
                const rawPinchStrength = 1 - Math.max(0, Math.min(1, pinchNorm));
                state.pinchStrength = state.pinchStrength * 0.85 + rawPinchStrength * 0.15;

                const wasPinching = state.isPinching;
                const wasDoublePinching = state.isDoublePinching;
                const wasSteering = state.isSteering;
                const hadTwoHands = state.twoHandsDetected;

                // Hysteresis: different thresholds for entering vs exiting pinch state
                const rawPinchState = state.isPinching
                    ? state.pinchStrength > config.pinchExitThreshold   // Stay pinching until below exit threshold
                    : state.pinchStrength > config.pinchEnterThreshold; // Only start pinching above enter threshold

                // Debounce the pinch state to prevent rapid toggling
                state.isPinching = debouncers.pinch.update(rawPinchState);

                // --- Grab Point Calculation with Filtering ---
                const rawGrabX = (thumbTip.x + indexTip.x) / 2;
                const rawGrabY = (thumbTip.y + indexTip.y) / 2;

                // Apply One Euro Filter for smooth, responsive tracking
                const grabPointX = filters.hand1.grabX.filter(rawGrabX);
                const grabPointY = filters.hand1.grabY.filter(rawGrabY);
                state.currentHandPos = { x: grabPointX, y: grabPointY };

                // --- TWO-HAND DETECTION ---
                if (results.multiHandLandmarks.length >= 2) {
                    state.twoHandsDetected = true;

                    // Get second hand (the one that's NOT the primary)
                    const secondHandIndex = primaryHandIndex === 0 ? 1 : 0;
                    const hand2 = results.multiHandLandmarks[secondHandIndex];
                    const h2Thumb = hand2[4];
                    const h2Index = hand2[8];
                    const h2PinchDist = Math.sqrt(Math.pow(h2Thumb.x - h2Index.x, 2) + Math.pow(h2Thumb.y - h2Index.y, 2));

                    const h2PinchMin = 0.04;
                    const h2PinchMax = 0.12;
                    const h2PinchNorm = (h2PinchDist - h2PinchMin) / (h2PinchMax - h2PinchMin);
                    const h2RawPinchStrength = 1 - Math.max(0, Math.min(1, h2PinchNorm));
                    state.hand2PinchStrength = state.hand2PinchStrength * 0.85 + h2RawPinchStrength * 0.15;

                    // Hand 2 pinch with hysteresis and debouncing
                    const rawH2PinchState = state.hand2PinchStrength > config.pinchEnterThreshold;
                    const isHand2Pinching = debouncers.pinch2.update(rawH2PinchState);

                    // --- GESTURE PRIORITY SYSTEM ---
                    // Priority: Namaste Reset > Double Pinch Zoom > Two-Hand Steering > Single-Hand Grab

                    // Filter palm positions for stable steering/zoom
                    const rawPalm1X = landmarks[0].x;
                    const rawPalm1Y = landmarks[0].y;
                    const rawPalm2X = hand2[0].x;
                    const rawPalm2Y = hand2[0].y;

                    const palm1X = filters.hand1.palmX.filter(rawPalm1X);
                    const palm1Y = filters.hand1.palmY.filter(rawPalm1Y);
                    const palm2X = filters.hand2.palmX.filter(rawPalm2X);
                    const palm2Y = filters.hand2.palmY.filter(rawPalm2Y);

                    const palm1 = { x: palm1X, y: palm1Y };
                    const palm2 = { x: palm2X, y: palm2Y };
                    const palmDist = Math.sqrt(Math.pow(palm1.x - palm2.x, 2) + Math.pow(palm1.y - palm2.y, 2));
                    const handDist = palmDist;
                    state.twoHandDistance = handDist;

                    // --- NAMASTE RESET (Priority 1 - Highest) ---
                    if (palmDist < 0.15) {
                        // TRIGGER RESET
                        state.objectOffset = { x: 0, y: 0, z: 0 };
                        state.objectRotation = { x: 0, y: 0, z: 0 };
                        state.twoHandScale = 1.0;
                        state.neutralDistance = null;
                        state.isGrabbing = false;
                        state.isDoublePinching = false;
                        state.isSteering = false;
                        state.twoHandStartAngle = null;
                        state.primaryHandLabel = null;

                        // Reset momentum
                        state.momentumActive = false;
                        state.velocity = { x: 0, y: 0 };
                        state.angularVelocity = 0;

                        // Reset all filters and debouncers for clean state
                        Object.values(filters.hand1).forEach(f => f.reset());
                        Object.values(filters.hand2).forEach(f => f.reset());
                        Object.values(debouncers).forEach(d => d.reset());

                        zoomText.innerText = "Reset!";
                        zoomDot.classList.add('active');
                        pinchDot.classList.remove('active');
                        pinchText.innerText = 'Namaste Reset';
                        return;
                    }

                    // --- DOUBLE PINCH ZOOM (Priority 2) ---
                    if (state.isPinching && isHand2Pinching) {
                        state.isDoublePinching = true;
                        state.isGrabbing = false;
                        state.isSteering = false;
                        state.twoHandStartAngle = null;

                        if (state.neutralDistance === null) {
                            state.neutralDistance = handDist;
                            zoomText.innerText = `Zoom Locked: Stretch/Compress`;
                        } else {
                            const ratio = handDist / state.neutralDistance;
                            let zoomSpeed = 0;

                            if (ratio > 1.1) {
                                zoomSpeed = (ratio - 1.1) * 0.05;
                                zoomText.innerText = `Zooming IN >> ${(state.twoHandScale * 100).toFixed(0)}%`;
                            } else if (ratio < 0.9) {
                                zoomSpeed = (ratio - 0.9) * 0.05;
                                zoomText.innerText = `Zooming OUT << ${(state.twoHandScale * 100).toFixed(0)}%`;
                            } else {
                                zoomText.innerText = `Zoom: ${(state.twoHandScale * 100).toFixed(0)}%`;
                            }

                            state.twoHandScale += zoomSpeed * state.twoHandScale;
                            state.twoHandScale = Math.max(0.1, Math.min(50.0, state.twoHandScale));
                        }

                        zoomDot.classList.add('active');
                        pinchDot.classList.add('active');
                        pinchText.innerText = 'Double Pinch Zoom';

                    // --- TWO-HAND STEERING (Priority 3) ---
                    // Activate when: one hand pinching, other hand NOT pinching (asymmetric grip)
                    } else if (state.isPinching && !isHand2Pinching && palmDist > 0.25) {
                        state.isDoublePinching = false;
                        state.neutralDistance = null;
                        state.isSteering = true;
                        state.isGrabbing = false; // CRITICAL: Disable grab rotation conflict

                        const angle = Math.atan2(palm2.y - palm1.y, palm2.x - palm1.x);

                        if (state.twoHandStartAngle === null || !wasSteering) {
                            state.twoHandStartAngle = angle;
                            state.twoHandStartObjRotation = state.objectRotation.z;
                        } else {
                            const deltaAngle = angle - state.twoHandStartAngle;
                            state.objectRotation.z = state.twoHandStartObjRotation - deltaAngle;
                        }

                        zoomDot.classList.add('active');
                        zoomText.innerText = 'Steering Mode';
                        pinchDot.classList.add('active');
                        pinchText.innerText = 'Steering...';

                    } else {
                        // No two-hand gesture active
                        state.isDoublePinching = false;
                        state.neutralDistance = null;
                        state.isSteering = false;
                        state.twoHandStartAngle = null;
                        zoomDot.classList.remove('active');
                        zoomText.innerText = 'Pinch both hands to zoom';
                    }

                } else {
                    // --- SINGLE HAND MODE ---
                    const wasInTwoHandMode = hadTwoHands;
                    state.twoHandsDetected = false;
                    state.isDoublePinching = false;
                    state.isSteering = false;
                    state.twoHandStartAngle = null;
                    state.neutralDistance = null;
                    state.hand2PinchStrength = state.hand2PinchStrength * 0.9;

                    zoomDot.classList.remove('active');
                    zoomText.innerText = 'Add second hand for zoom';

                    // --- RE-INITIALIZE GRAB after returning from two-hand mode ---
                    // This fixes the "sudden jump" bug when transitioning
                    if (wasInTwoHandMode && state.isPinching) {
                        state.isGrabbing = true;
                        state.grabStartHandPos = { x: grabPointX, y: grabPointY };
                        state.grabStartObjectPos = {
                            x: state.objectOffset.x,
                            y: state.objectOffset.y,
                            z: state.objectOffset.z
                        };
                        const indexMCP = landmarks[5];
                        state.grabStartHandAngle = Math.atan2(indexMCP.y - wrist.y, indexMCP.x - wrist.x);
                        state.grabStartObjectRotation = {
                            x: state.objectRotation.x,
                            y: state.objectRotation.y,
                            z: state.objectRotation.z
                        };
                    }
                }

                // --- SINGLE-HAND GRAB-AND-DRAG (Priority 4 - Lowest) ---
                // Only runs when NOT in any two-hand mode
                if (!state.isSteering && !state.isDoublePinching) {

                    // Pinch just started - initialize grab
                    if (state.isPinching && !wasPinching) {
                        state.isGrabbing = true;
                        state.grabStartHandPos = { x: grabPointX, y: grabPointY };
                        state.grabStartObjectPos = {
                            x: state.objectOffset.x,
                            y: state.objectOffset.y,
                            z: state.objectOffset.z
                        };
                        const indexMCP = landmarks[5];
                        state.grabStartHandAngle = Math.atan2(indexMCP.y - wrist.y, indexMCP.x - wrist.x);
                        state.grabStartObjectRotation = {
                            x: state.objectRotation.x,
                            y: state.objectRotation.y,
                            z: state.objectRotation.z
                        };

                        // Lock hand identity
                        if (results.multiHandedness && results.multiHandedness.length > 0) {
                            state.primaryHandLabel = results.multiHandedness[primaryHandIndex].label;
                        }

                        // Initialize momentum tracking
                        state.velocity = { x: 0, y: 0 };
                        state.angularVelocity = 0;
                        state.lastGrabPos = { x: state.objectOffset.x, y: state.objectOffset.y };
                        state.lastGrabAngle = state.objectRotation.z;
                        state.momentumActive = false;
                    }

                    // While grabbing - apply translation and rotation
                    if (state.isGrabbing && state.isPinching) {
                        const sensitivity = 25;
                        const deltaX = (grabPointX - state.grabStartHandPos.x) * sensitivity;
                        const deltaY = -(grabPointY - state.grabStartHandPos.y) * sensitivity;

                        state.objectOffset.x = state.grabStartObjectPos.x - deltaX;
                        state.objectOffset.y = state.grabStartObjectPos.y + deltaY;

                        // Only apply rotation if NOT steering (prevent conflict)
                        if (!state.twoHandsDetected) {
                            const indexMCP = landmarks[5];
                            const currentHandAngle = Math.atan2(indexMCP.y - wrist.y, indexMCP.x - wrist.x);
                            const deltaAngle = currentHandAngle - state.grabStartHandAngle;
                            state.objectRotation.z = state.grabStartObjectRotation.z - deltaAngle;
                        }

                        // Track velocity for momentum (position + rotation)
                        const dx = state.objectOffset.x - state.lastGrabPos.x;
                        const dy = state.objectOffset.y - state.lastGrabPos.y;
                        state.velocity.x = state.velocity.x * 0.7 + dx * 0.3;
                        state.velocity.y = state.velocity.y * 0.7 + dy * 0.3;
                        state.lastGrabPos.x = state.objectOffset.x;
                        state.lastGrabPos.y = state.objectOffset.y;

                        const dAngle = state.objectRotation.z - state.lastGrabAngle;
                        state.angularVelocity = state.angularVelocity * 0.7 + dAngle * 0.3;
                        state.lastGrabAngle = state.objectRotation.z;

                        pinchDot.classList.add('active');
                        pinchText.innerText = 'Grabbing...';
                    }

                    // Pinch released
                    if (!state.isPinching && wasPinching) {
                        state.isGrabbing = false;
                        state.momentumActive = true; // Enable momentum continuation
                        state.primaryHandLabel = null; // Release hand lock
                    }
                }

                // Update UI for non-grabbing pinch state
                if (!state.isGrabbing && !state.isSteering && !state.isDoublePinching) {
                    if (state.isPinching) {
                        pinchDot.classList.add('active');
                        pinchText.innerText = 'Pinch: Active';
                    } else {
                        pinchDot.classList.remove('active');
                        pinchText.innerText = `Pinch: ${Math.round(state.pinchStrength * 100)}%`;
                    }
                }

            } else {
                // --- NO HANDS DETECTED ---
                state.handDetected = false;
                state.twoHandsDetected = false;
                statusDot.classList.remove('active');
                statusText.innerText = "No Hands Detected";

                // Gradual decay
                state.tension = state.tension * 0.985;
                state.pinchStrength = state.pinchStrength * 0.95;
                state.hand2PinchStrength = state.hand2PinchStrength * 0.95;

                // Reset all gesture states
                state.isPinching = false;
                state.isGrabbing = false;
                state.isZooming = false;
                state.isSteering = false;
                state.isDoublePinching = false;
                state.twoHandStartAngle = null;
                state.neutralDistance = null;
                state.primaryHandLabel = null;

                // Reset filters and debouncers when hands are lost
                Object.values(filters.hand1).forEach(f => f.reset());
                Object.values(filters.hand2).forEach(f => f.reset());
                Object.values(debouncers).forEach(d => d.reset());

                pinchDot.classList.remove('active');
                pinchText.innerText = 'Pinch: Inactive';
                zoomDot.classList.remove('active');
                zoomText.innerText = 'Show hands to begin';
            }
        }

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Webcam initialization
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });

        cameraUtils.start()
            .then(() => console.log('Camera started'))
            .catch(err => {
                console.error('Camera error', err);
                statusText.innerText = "Camera Access Denied";
                document.getElementById('loader').classList.add('hidden');
            });


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const positionAttribute = geometry.attributes.position;
            const currentPositions = positionAttribute.array;

            // Time for idle animation
            state.time += 0.01;

            // Determine Scale Factor based on Hand Tension
            // High tension (fist) = Contract/Small or Explode? 
            // Requirements: "detect tension... Map this to: Scaling... Expansion/contraction"
            // Let's make High Tension = Expansion (Power up) or Contraction (Crush).
            // Let's go with: Open Hand = Relaxed (Normal Size), Closed Hand = High Tension (Particles contract tightly and shake)

            // Actually, usually "Opening hand" feels like expansion.
            // Let's do: Closed Fist = Contract/condense to center. Open Hand = Expand beyond normal.

            // Base scale is 1.0
            // Tension 1.0 (Closed) -> Scale 0.5
            // Tension 0.0 (Open) -> Scale 1.5
            // But if hands not detected, default to 1.0 idle breathing

            let targetScaleFactor = 1.0;
            if (state.handDetected) {
                // Map tension (0..1) to scale
                // Tension 0 (Open) -> 1.5
                // Tension 1 (Closed) -> 0.4
                targetScaleFactor = 1.5 - (state.tension * 1.1);
            } else {
                // Idle breathing
                targetScaleFactor = 1.0 + Math.sin(state.time) * 0.1;
            }
            // Smooth transition to target scale factor (prevents sudden jumps)
            state.lastScaleFactor += (targetScaleFactor - state.lastScaleFactor) * 0.08;
            const scaleFactor = state.lastScaleFactor;

            // Loop through particles
            for (let i = 0; i < config.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // 1. Interpolate towards target shape
                const tx = targetPositions[ix];
                const ty = targetPositions[iy];
                const tz = targetPositions[iz];

                // Lerp current to target
                currentPositions[ix] += (tx - currentPositions[ix]) * config.lerpSpeed;
                currentPositions[iy] += (ty - currentPositions[iy]) * config.lerpSpeed;
                currentPositions[iz] += (tz - currentPositions[iz]) * config.lerpSpeed;

                // 2. Apply Interaction (Scale/Explode based on tension)
                // We modify the rendered position relative to center (0,0,0) or center of mass?
                // Simple scaling around (0,0,0)

                // We don't overwrite the buffer 'currentPositions' with the scaled version permanently, 
                // otherwise it drifts. We apply the scale to the coordinate we write back, 
                // BUT we need 'currentPositions' to store the shape state.

                // Solution: We update 'currentPositions' to move towards 'targetPositions'. 
                // BUT, to render the scale effect, we might need to update the actual geometry 
                // differently or apply a global scale to the Object3D.

                // Applying global scale to the Points object is most efficient and smooth.
                // However, the requirement says "Map tension to... Scaling of the entire particle group".
                // Yes, valid.
            }

            // Update Geometry
            positionAttribute.needsUpdate = true;

            // Apply Scale & Rotation

            // Apply momentum after release (position + rotation)
            if (state.momentumActive && !state.isGrabbing) {
                // Apply velocity to position
                state.objectOffset.x += state.velocity.x;
                state.objectOffset.y += state.velocity.y;

                // Apply angular velocity to rotation
                state.objectRotation.z += state.angularVelocity;

                // Exponential decay (friction = 0.92)
                const friction = 0.92;
                state.velocity.x *= friction;
                state.velocity.y *= friction;
                state.angularVelocity *= friction;

                // Stop momentum when all velocities are negligible
                const speed = Math.sqrt(state.velocity.x ** 2 + state.velocity.y ** 2);
                const angSpeed = Math.abs(state.angularVelocity);
                if (speed < 0.001 && angSpeed < 0.0001) {
                    state.momentumActive = false;
                    state.velocity = { x: 0, y: 0 };
                    state.angularVelocity = 0;
                }
            }

            // Auto-rotate ONLY if not grabbing (and not in momentum)
            if (!state.isGrabbing && !state.momentumActive) {
                state.objectRotation.y += 0.002;
            }

            // Apply proper rotations from state
            // Lerp towards the state rotation for smoothness
            // We use a simple lerp on Euler angles (works fine for small increments)
            particles.rotation.x = state.objectRotation.x;
            particles.rotation.y = state.objectRotation.y;
            particles.rotation.z = state.objectRotation.z;

            // Smoothly interpolate the object scale (0.05 for very smooth transitions)
            // Priority: Two-handed zoom > Grab (Stable) > Single-hand tension > Idle
            let finalScale = scaleFactor;

            if (state.twoHandsDetected) {
                // Iron Man Zoom
                finalScale = state.twoHandScale;
            } else if (state.isGrabbing) {
                // STABLE GRAB: When holding the object, keep it at a stable size
                // We use the last known zoom scale (or default 1.0) so it doesn't shrink
                finalScale = Math.max(state.twoHandScale, 1.0);
            }
            // Else fall back to 'scaleFactor' (Textion/Idle)

            particles.scale.lerp(new THREE.Vector3(finalScale, finalScale, finalScale), 0.08);

            // --- Color Logic with Visual Feedback ---
            let targetColor = state.baseColor.clone();

            // Color shift during grab (warmer tint)
            if (state.isGrabbing) {
                const grabTint = new THREE.Color(0xffaa44); // Warm orange
                targetColor.lerp(grabTint, 0.3);
            }

            // Brighter during zoom
            if (state.isDoublePinching) {
                const zoomTint = new THREE.Color(0xffffff); // White boost
                targetColor.lerp(zoomTint, 0.2);
            }

            // Slight red shift during high tension
            if (state.tension > 0.7 && !state.isGrabbing) {
                const tensionTint = new THREE.Color(0xff6666); // Reddish
                targetColor.lerp(tensionTint, (state.tension - 0.7) * 1.5);
            }

            material.color.lerp(targetColor, 0.1);

            // --- Apply Grab Offset (Pinch-and-Drag) ---
            // Smoothly lerp the particle group position towards the target offset
            const targetX = state.objectOffset.x;
            const targetY = state.objectOffset.y;

            // Add jitter if high tension (but not when grabbing)
            let jitterX = 0, jitterY = 0;
            if (state.tension > 0.7 && !state.isGrabbing) {
                // Intensity scales with tension (0.7-1.0  0-1)
                const intensity = (state.tension - 0.7) / 0.3;
                jitterX = (Math.random() - 0.5) * 0.4 * intensity;
                jitterY = (Math.random() - 0.5) * 0.4 * intensity;
            }

            // Smooth position update
            particles.position.x += ((targetX + jitterX) - particles.position.x) * 0.1;
            particles.position.y += ((targetY + jitterY) - particles.position.y) * 0.1;

            // --- Particle Size Effects ---
            let targetSize = config.baseSize;

            // Glow effect during zoom (larger particles)
            if (state.isDoublePinching) {
                targetSize = config.baseSize * 1.4;
            }

            // Pulse effect during high tension
            if (state.tension > 0.7 && !state.isGrabbing) {
                const pulse = Math.sin(state.time * 15) * 0.03 * ((state.tension - 0.7) / 0.3);
                targetSize += pulse;
            }

            // Smooth size transition
            material.size += (targetSize - material.size) * 0.1;

            renderer.render(scene, camera);
        }

        animate();

        // --- Keyboard Controls ---
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                // RESET (Same as Namaste)
                state.objectOffset = { x: 0, y: 0, z: 0 };
                state.objectRotation = { x: 0, y: 0, z: 0 };
                state.twoHandScale = 1.0;
                state.neutralDistance = null;
                state.isGrabbing = false;
                state.isDoublePinching = false;

                const zoomText = document.getElementById('status-text');
                if (zoomText) zoomText.innerText = "System Reset";
            }
        });

    </script>
</body>

</html>