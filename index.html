<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AetherTouch - Interactive 3D Particles</title>

    <style>
        :root {
            --primary-color: #00f3ff;
            --secondary-color: #ff0055;
            --bg-color: #050510;
            --panel-bg: rgba(10, 10, 20, 0.85);
            --text-color: #e0e0ff;
            --accent-color: #7000ff;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* Error Logger (Debug) */
        #error-log {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            z-index: 9999;
            display: none;
            max-width: 80%;
            font-family: monospace;
        }

        /* --- ZEN MODE UI --- */

        /* Top Header (Minimal) */
        #top-bar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            /* Let clicks pass through */
            z-index: 10;
            box-sizing: border-box;
        }

        .header-left {
            pointer-events: auto;
            text-shadow: 0 0 10px var(--primary-color);
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 300;
        }

        h1 b {
            font-weight: 700;
        }

        .subtitle {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 5px;
            display: block;
        }

        /* Video Feed - Mini Rectangle */
        #video-container {
            pointer-events: auto;
            position: relative;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 15px var(--primary-color);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        #video-container:hover {
            transform: scale(1.05);
        }

        #video-container.collapsed {
            width: 30px;
            height: 30px;
            opacity: 0.5;
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: none;
        }

        #video-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            /* Mirror */
        }

        /* Bottom Dock */
        #bottom-dock {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            padding: 15px 25px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 20px;
            align-items: center;
            z-index: 10;
            pointer-events: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            transition: bottom 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            width: auto;
            max-width: 90vw;
            overflow-x: auto;
        }

        .dock-section {
            display: flex;
            gap: 10px;
            align-items: center;
            padding-right: 20px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .dock-section:last-child {
            border-right: none;
            padding-right: 0;
        }

        .dock-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.6;
            margin-bottom: 5px;
            display: block;
            position: absolute;
            top: -25px;
            left: 10px;
            pointer-events: none;
        }

        /* Buttons */
        .tpl-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            white-space: nowrap;
        }

        .tpl-btn:hover {
            background: var(--primary-color);
            color: #000;
            box-shadow: 0 0 15px var(--primary-color);
        }

        /* Color Picker */
        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: none;
            cursor: pointer;
            padding: 0;
            overflow: hidden;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
        }

        /* Status & Feedback */
        .status-panel {
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 0.9rem;
            min-width: 150px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: #444;
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            transition: background 0.3s;
        }

        .status-dot.active {
            background: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-color);
        }

        .status-text {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Debug Override */
        #fps-counter {
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
        }

        /* Webcam feedback (hidden but useful for debugging if needed, currently set to display none) */
        /* Webcam feedback - Integrated into UI */
        #video-feed {
            width: 100%;
            height: auto;
            border-radius: 8px;
            opacity: 0.8;
            transform: scaleX(-1);
            /* Mirror */
            display: block;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 1rem;
            background: #000;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Help Modal */
        #help-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            z-index: 200;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #help-modal.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .help-content {
            background: var(--panel-bg);
            padding: 30px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 400px;
            width: 90%;
            color: #fff;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            transform: translateY(20px);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        #help-modal.visible .help-content {
            transform: translateY(0);
        }

        .help-content h2 {
            margin-top: 0;
            color: var(--primary-color);
            text-align: center;
        }

        .help-list {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }

        .help-list li {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            font-size: 1.1rem;
        }

        .help-icon {
            font-size: 1.5rem;
            margin-right: 15px;
            width: 40px;
            text-align: center;
        }

        .close-btn {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            width: 100%;
            font-weight: bold;
            cursor: pointer;
            font-size: 1rem;
            margin-top: 10px;
        }

        /* Help Toggle Button */
        #help-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 20;
            font-weight: bold;
            font-size: 1.2rem;
            transition: all 0.2s ease;
        }

        #help-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
    </style>
    <style>
        /* Responsive Adjustments */
        @media (max-width: 600px) {
            #ui-container {
                width: 90%;
                left: 50%;
                transform: translateX(-50%);
                top: auto;
                bottom: 20px;
                right: auto;
                padding: 15px;
            }

            h1 {
                font-size: 1rem;
                text-align: center;
            }

            .status {
                justify-content: center;
            }

            #video-feed {
                max-height: 120px;
                object-fit: cover;
            }

            #help-toggle {
                top: 10px;
                left: 10px;
                width: 35px;
                height: 35px;
            }

            #fps-counter {
                top: 10px;
                left: 50px;
            }
        }

        /* Enhanced Button Hover Effects */
        .tpl-btn {
            position: relative;
            overflow: hidden;
        }

        .tpl-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }

        .tpl-btn:hover::after {
            width: 150%;
            height: 150%;
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- Fingerpose - Custom gesture recognition -->
    <script src="https://cdn.jsdelivr.net/npm/fingerpose@0.1.0/dist/fingerpose.min.js"></script>

    <!-- MediaPipe Face Mesh (For Head Tracking/Parallax) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
</head>

<body>

    <div class="loading-overlay" id="loader">
        <div class="spinner"></div>
        <p style="margin-top: 1rem;">Loading AI Models...</p>
    </div>

    <div id="top-bar">
        <div class="header-left">
            <h1>Aether<b>Touch</b></h1>
            <span class="subtitle">GTM Engineering Dashboard</span>
            <div id="fps-counter">FPS: 0</div>
        </div>

        <div id="video-container" title="Click to toggle size">
            <video id="video-feed" autoplay playsinline></video>
        </div>
    </div>

    <!-- Help Modal (Same as before) -->
    <div id="help-modal">
        <div class="help-content">
            <h2>Gesture Guide</h2>
            <ul class="help-list">
                <li><span class="help-icon">ü§è</span>
                    <div><strong>Grab & Drag</strong><br><small>Pinch index+thumb & move</small></div>
                </li>
                <li><span class="help-icon">üëê</span>
                    <div><strong>Elastic Zoom</strong><br><small>Pinch both hands & pull apart</small></div>
                </li>
                <li><span class="help-icon">‚ò∏Ô∏è</span>
                    <div><strong>Steering</strong><br><small>One pinch + One open hand</small></div>
                </li>
                <li><span class="help-icon">üôè</span>
                    <div><strong>System Reset</strong><br><small>Namaste (Palms together)</small></div>
                </li>
            </ul>
            <button class="close-btn" onclick="toggleHelp()">Got it!</button>
        </div>
    </div>

    <!-- Tooltip (Holographic Data) -->
    <div id="data-tooltip"
        style="position: absolute; display: none; background: rgba(0,0,0,0.8); color: white; padding: 10px; border: 1px solid #00f3ff; border-radius: 8px; pointer-events: none; z-index: 1000; font-family: monospace;">
        <div id="tt-title" style="font-weight: bold; color: #00f3ff; margin-bottom: 5px;"></div>
        <div id="tt-value"></div>
    </div>

    <!-- Canvas -->
    <div id="canvas-container"></div>

    <!-- Bottom Dock -->
    <div id="bottom-dock">
        <!-- Status Section -->
        <div class="dock-section">
            <div class="status-panel">
                <div class="status-item">
                    <div class="status-dot" id="status-dot"></div>
                    <span class="status-text" id="status-text">Initializing...</span>
                </div>
                <div class="status-item">
                    <div class="status-dot" id="pinch-dot"></div>
                    <span class="status-text" id="pinch-text">Pinch: Inactive</span>
                </div>
                <div class="status-item">
                    <div class="status-dot" id="zoom-dot"></div>
                    <span class="status-text" id="zoom-text">Zoom: Ready</span>
                </div>
            </div>
        </div>

        <!-- Shapes Section -->
        <div class="dock-section">
            <span class="dock-label">Views</span>
            <button class="tpl-btn" data-shape="sphere">Sphere</button>
            <button class="tpl-btn" data-shape="saturn">Saturn</button>
            <button class="tpl-btn" data-shape="funnel">Revenue Funnel</button>
            <button class="tpl-btn" data-shape="globe">Global Command</button>
            <button class="tpl-btn" data-shape="journey">Journey Flow (New)</button>
        </div>

        <!-- Color Section -->
        <div class="dock-section">
            <span class="dock-label">Style</span>
            <input type="color" id="color-picker" value="#00f3ff" title="Change Particle Color">
        </div>

        <!-- Tools Section -->
        <div class="dock-section">
            <button class="tpl-btn" onclick="toggleHelp()">Help (?)</button>
        </div>
    </div>
    </div>

    <p style="font-size: 0.7rem; color: #666; text-align: center; margin-top: 1rem;">
        Created by <a href="https://www.linkedin.com/in/gtm-engineer-mathew/" target="_blank"
            style="color: var(--primary-color); text-decoration: none;">Mathew Joseph</a>
    </p>
    </div>

    <script>
        // Global Error Handler
        window.onerror = function (msg, url, line, col, error) {
            const errorLog = document.getElementById('error-log');
            if (errorLog) {
                errorLog.style.display = 'block';
                errorLog.innerHTML += `<div>Error: ${msg} <br> Line: ${line}</div>`;
            }
            console.error("Critical Error", msg, error);
            document.getElementById('loader').innerText = "Error Loading App";
            return false;
        };

        // --- One Euro Filter (Industry-standard smoothing for gesture tracking) ---
        // Reduces jitter while maintaining responsiveness
        class OneEuroFilter {
            constructor(minCutoff = 1.0, beta = 0.007, dCutoff = 1.0) {
                this.minCutoff = minCutoff;
                this.beta = beta;
                this.dCutoff = dCutoff;
                this.x = null;
                this.dx = 0;
                this.lastTime = null;
            }

            alpha(cutoff, dt) {
                const tau = 1.0 / (2 * Math.PI * cutoff);
                return 1.0 / (1.0 + tau / dt);
            }

            filter(x, timestamp = null) {
                if (this.lastTime === null) {
                    this.x = x;
                    this.lastTime = timestamp || performance.now() / 1000;
                    return x;
                }

                const now = timestamp || performance.now() / 1000;
                const dt = Math.max(now - this.lastTime, 0.001);
                this.lastTime = now;

                const dx = (x - this.x) / dt;
                const alphaDx = this.alpha(this.dCutoff, dt);
                this.dx = alphaDx * dx + (1 - alphaDx) * this.dx;

                const cutoff = this.minCutoff + this.beta * Math.abs(this.dx);
                const alphaX = this.alpha(cutoff, dt);
                this.x = alphaX * x + (1 - alphaX) * this.x;

                return this.x;
            }

            reset() {
                this.x = null;
                this.dx = 0;
                this.lastTime = null;
            }
        }

        // --- Gesture State Debouncer ---
        // Prevents rapid state transitions that cause glitches
        class GestureDebouncer {
            constructor(enterDelay = 50, exitDelay = 100) {
                this.enterDelay = enterDelay;
                this.exitDelay = exitDelay;
                this.state = false;
                this.pendingState = false;
                this.lastChangeTime = 0;
            }

            update(rawState) {
                const now = performance.now();

                if (rawState !== this.pendingState) {
                    this.pendingState = rawState;
                    this.lastChangeTime = now;
                }

                const delay = this.pendingState ? this.enterDelay : this.exitDelay;

                if (this.pendingState !== this.state && (now - this.lastChangeTime) >= delay) {
                    this.state = this.pendingState;
                }

                return this.state;
            }

            reset() {
                this.state = false;
                this.pendingState = false;
                this.lastChangeTime = 0;
            }
        }

        // --- Tooltip Elements ---
        const tooltip = document.getElementById('data-tooltip');
        const ttTitle = document.getElementById('tt-title');
        const ttValue = document.getElementById('tt-value');

        // --- Fingerpose Custom Gesture Definitions ---
        const Finger = fp.Finger;
        const FingerCurl = fp.FingerCurl;
        const FingerDirection = fp.FingerDirection;

        // Pinch gesture: thumb and index tips close together
        const pinchGesture = new fp.GestureDescription('pinch');
        pinchGesture.addCurl(Finger.Thumb, FingerCurl.HalfCurl, 1.0);
        pinchGesture.addCurl(Finger.Index, FingerCurl.HalfCurl, 1.0);
        pinchGesture.addCurl(Finger.Middle, FingerCurl.NoCurl, 0.5);
        pinchGesture.addCurl(Finger.Ring, FingerCurl.NoCurl, 0.5);
        pinchGesture.addCurl(Finger.Pinky, FingerCurl.NoCurl, 0.5);

        // Open hand gesture: all fingers extended
        const openHandGesture = new fp.GestureDescription('open_hand');
        openHandGesture.addCurl(Finger.Thumb, FingerCurl.NoCurl, 1.0);
        openHandGesture.addCurl(Finger.Index, FingerCurl.NoCurl, 1.0);
        openHandGesture.addCurl(Finger.Middle, FingerCurl.NoCurl, 1.0);
        openHandGesture.addCurl(Finger.Ring, FingerCurl.NoCurl, 1.0);
        openHandGesture.addCurl(Finger.Pinky, FingerCurl.NoCurl, 1.0);

        // Fist gesture: all fingers curled (high tension)
        const fistGesture = new fp.GestureDescription('fist');
        fistGesture.addCurl(Finger.Thumb, FingerCurl.FullCurl, 1.0);
        fistGesture.addCurl(Finger.Index, FingerCurl.FullCurl, 1.0);
        fistGesture.addCurl(Finger.Middle, FingerCurl.FullCurl, 1.0);
        fistGesture.addCurl(Finger.Ring, FingerCurl.FullCurl, 1.0);
        fistGesture.addCurl(Finger.Pinky, FingerCurl.FullCurl, 1.0);

        // Create gesture estimator with all custom gestures
        const gestureEstimator = new fp.GestureEstimator([
            pinchGesture,
            openHandGesture,
            fistGesture
        ]);

        // --- Configuration & State ---
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const config = {
            particleCount: isMobile ? 2000 : 5000,
            baseSize: 0.15,
            lerpSpeed: 0.05,
            handInteractionStrength: 2.0,
            // Pinch detection with hysteresis (different thresholds for enter/exit)
            pinchEnterThreshold: 0.55,  // Lowered from 0.65 for easier triggering
            pinchExitThreshold: 0.40,   // Lowered from 0.50
            // Gesture timing
            gestureEnterDelay: 60,   // ms to wait before activating gesture
            gestureExitDelay: 120    // ms to wait before deactivating gesture
        };

        // --- Filters for smooth hand tracking ---
        const filters = {
            hand1: {
                grabX: new OneEuroFilter(1.0, 0.01),
                grabY: new OneEuroFilter(1.0, 0.01),
                palmX: new OneEuroFilter(2.0, 0.02),  // More responsive for Namaste
                palmY: new OneEuroFilter(2.0, 0.02)
            },
            hand2: {
                palmX: new OneEuroFilter(2.0, 0.02),  // More responsive for Namaste
                palmY: new OneEuroFilter(2.0, 0.02)
            }
        };

        // --- Gesture Debouncers ---
        const debouncers = {
            pinch: new GestureDebouncer(config.gestureEnterDelay, config.gestureExitDelay),
            pinch2: new GestureDebouncer(config.gestureEnterDelay, config.gestureExitDelay),
            steering: new GestureDebouncer(100, 150),
            doublePinch: new GestureDebouncer(80, 100)
        };

        const state = {
            currentShape: 'sphere',
            handDetected: false,
            // ... (existing state) ...

            // --- DATA LAYER (Phase 8) ---
            data: {
                revenue: { forecast: "Loading...", growth_yoy: 0 },
                funnel: { conversion_rate: 0 },
                regions: { emea: { growth: 0 }, apac: { growth: 0 } }
            },


            twoHandsDetected: false,
            tension: 0, // 0 to 1 (relaxed to clenched)
            pinchStrength: 0, // 0 to 1 (open to pinched)
            rotationX: 0,
            rotationY: 0,
            // Parallax State
            parallax: {
                x: 0,
                y: 0,
                targetX: 0,
                targetY: 0
            },
            // Hand 2 specific
            isHand2Pinching: false,
            isGrabbing: false,
            grabStartHandPos: { x: 0, y: 0 },
            grabStartObjectPos: { x: 0, y: 0, z: 0 },
            grabStartHandAngle: 0,
            grabStartObjectRotation: { x: 0, y: 0, z: 0 },
            currentHandPos: { x: 0, y: 0 },
            objectOffset: { x: 0, y: 0, z: 0 },
            objectRotation: { x: 0, y: 0, z: 0 }, // Accumulated rotation
            // Hand identity tracking (prevents swap issues)
            primaryHandLabel: null, // 'Left' or 'Right' - which hand is controlling
            // Elastic Zoom State
            twoHandDistance: 0,
            neutralDistance: null,    // The reference distance for "Zero speed"
            twoHandScale: 1.0,        // The persisted scale value
            isDoublePinching: false,  // Active trigger for Elastic Zoom

            twoHandStartAngle: null,   // For Steering - null indicates not yet initialized
            twoHandStartObjRotation: 0, // For Steering Z
            isSteering: false,         // New Flag for Closed-Hand Steering
            hand2PinchStrength: 0,     // Smoothed pinch strength for hand 2
            isZooming: false,          // Flag for zoom state
            lastScaleFactor: 1.0,      // For smooth scale transitions
            targetColor: new THREE.Color(0x00f3ff),
            baseColor: new THREE.Color(0x00f3ff),
            time: 0,
            // Momentum/Inertia state
            velocity: { x: 0, y: 0 },
            angularVelocity: 0,
            lastGrabPos: { x: 0, y: 0 },
            lastGrabAngle: 0,
            momentumActive: false,
            // Namaste cooldown (prevents accidental re-triggers)
            namasteCooldownUntil: 0,
            // Fingerpose gesture scores (0-10)
            gestureScores: {
                pinch: 0,
                open_hand: 0,
                fist: 0
            },
            gestureScores2: {  // For second hand
                pinch: 0,
                open_hand: 0,
                fist: 0
            }
        };

        // --- Fetch Real Data (Phase 8) ---
        async function fetchGTMData() {
            try {
                const response = await fetch('data.json');
                if (!response.ok) throw new Error("API Error");
                const data = await response.json();
                state.data = data;
                console.log("GTM Data Loaded:", data);

                // Update UI Status to show connection
                const statusText = document.getElementById('status-text');
                if (statusText) statusText.innerText = "System Ready (Live Data)";

            } catch (err) {
                console.error("Data Fetch Failed:", err);
                // Fallback / Offline Mode
                state.data.revenue.forecast = "$1.2M (Cached)";
                state.data.regions.apac.growth = 15;
            }
        }

        // Load data on startup
        fetchGTMData();

        // --- Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;
        camera.position.y = 2;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // --- Particle System ---
        // We'll use BufferGeometry for performance
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(config.particleCount * 3);
        const targetPositions = new Float32Array(config.particleCount * 3); // Where particles want to go
        const originalPositions = new Float32Array(config.particleCount * 3); // Base for shapes

        // Initialize with random positions
        for (let i = 0; i < config.particleCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 50;
            targetPositions[i] = positions[i];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Create a custom material or use PointsMaterial
        // Using a texture sprite for particles makes them look nicer
        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
        const material = new THREE.PointsMaterial({
            size: config.baseSize,
            color: state.targetColor,
            map: sprite,
            alphaTest: 0.5,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Shape Generators ---
        // Helper to set a point in the target array
        function setTarget(i, x, y, z) {
            targetPositions[i * 3] = x;
            targetPositions[i * 3 + 1] = y;
            targetPositions[i * 3 + 2] = z;
        }

        const shapes = {
            sphere: () => {
                const r = 6;
                for (let i = 0; i < config.particleCount; i++) {
                    const phi = Math.acos(-1 + (2 * i) / config.particleCount);
                    const theta = Math.sqrt(config.particleCount * Math.PI) * phi;

                    const x = r * Math.cos(theta) * Math.sin(phi);
                    const y = r * Math.sin(theta) * Math.sin(phi);
                    const z = r * Math.cos(phi);
                    setTarget(i, x, y, z);
                }
            },
            heart: () => {
                // Parametric heart
                // x = 16sin^3(t)
                // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                // z = varied depth
                const scale = 0.35;
                for (let i = 0; i < config.particleCount; i++) {
                    const t = Math.random() * Math.PI * 2;
                    // Spread points somewhat randomly but adhering to volume
                    const r = Math.random(); // Variance for filling inside

                    // Simple outline
                    let x = 16 * Math.pow(Math.sin(t), 3);
                    let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                    let z = (Math.random() - 0.5) * 4; // Thickness

                    // Randomize slightly to fill volume
                    const v = 1 - Math.random() * 0.2;
                    x *= v; y *= v;

                    setTarget(i, x * scale, y * scale + 2, z * scale);
                }
            },
            flower: () => {
                // Rose curve (polar) r = cos(k*theta)
                const k = 4; // 4 petals
                const scale = 4;
                for (let i = 0; i < config.particleCount; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const r_curve = Math.cos(k * theta);

                    // Add thickness and layers
                    const r = (r_curve + 0.2) * scale * Math.random();

                    const x = r * Math.cos(theta);
                    const y = r * Math.sin(theta);
                    const z = (Math.random() - 0.5) * (2 - r / scale); // Thicker center

                    setTarget(i, x, y + 2, z);
                }
            },
            saturn: () => {
                const planetRadius = 3.5;
                const ringInner = 4.5;
                const ringOuter = 8;

                for (let i = 0; i < config.particleCount; i++) {
                    if (i < config.particleCount * 0.4) {
                        // Planet body (Sphere)
                        const phi = Math.acos(-1 + (2 * i) / (config.particleCount * 0.4));
                        const theta = Math.sqrt(config.particleCount * Math.PI) * phi;
                        const x = planetRadius * Math.cos(theta) * Math.sin(phi);
                        const y = planetRadius * Math.sin(theta) * Math.sin(phi);
                        const z = planetRadius * Math.cos(phi);
                        setTarget(i, x, y, z);
                    } else {
                        // Rings (Disc)
                        const angle = Math.random() * Math.PI * 2;
                        const dist = ringInner + Math.random() * (ringOuter - ringInner);
                        const x = dist * Math.cos(angle);
                        const z = dist * Math.sin(angle);
                        const y = (Math.random() - 0.5) * 0.2; // Thin ring

                        // Tilt the ring
                        const tilt = Math.PI / 6;
                        const yt = y * Math.cos(tilt) - x * Math.sin(tilt);
                        const xt = y * Math.sin(tilt) + x * Math.cos(tilt);

                        setTarget(i, xt, yt, z);
                    }
                }
            },
            buddha: () => {
                // Simplified Meditating Figure (Solid Geometry Construction)
                // Head (sphere), Body (Ellipsoid), Legs (Torus segment/Cylinders)
                const headR = 1.5;
                const bodyR = 2.5;

                for (let i = 0; i < config.particleCount; i++) {
                    const r = Math.random();
                    // Distribute points: 20% Head, 40% Body, 40% Legs/Base

                    if (r < 0.2) {
                        // Head
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        const rad = headR;
                        const x = rad * Math.sin(phi) * Math.cos(theta);
                        const y = rad * Math.sin(phi) * Math.sin(theta) + 3.5; // Offset up
                        const z = rad * Math.cos(phi);
                        setTarget(i, x, y, z);
                    } else if (r < 0.6) {
                        // Body
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        const x = bodyR * 0.9 * Math.sin(phi) * Math.cos(theta);
                        const y = bodyR * 1.2 * Math.sin(phi) * Math.sin(theta); // Elongated Y
                        const z = bodyR * 0.8 * Math.cos(phi);
                        setTarget(i, x, y, z);
                    } else {
                        // Legs/Base (Wide flatten sphere/torus approx)
                        const angle = Math.random() * Math.PI * 2; // -PI to PI
                        // We want a semi-circle loop for crossed legs
                        const rad = 3.5 + Math.random() * 0.5;
                        const x = rad * Math.cos(angle);
                        const y = -2.0 + (Math.random() * 1.5);
                        const z = rad * Math.sin(angle) * 0.6; // Flattened depth

                        // Cut off back to make it look like knees forward? 
                        // Lets just make a wide base ellipsoid
                        setTarget(i, x, y, z);
                    }
                }
            },
            funnel: () => {
                // GTM Revenue Funnel (Tornado/Cone)
                // Top (Leads) -> Wide, Bottom (Revenue) -> Narrow
                for (let i = 0; i < config.particleCount; i++) {
                    const progress = i / config.particleCount; // 0 to 1

                    // Distribution: More particles at the top (Leads)
                    // We map linear index to a powered distribution 
                    const h = (Math.pow(Math.random(), 0.8) * 7) - 3; // -3 to 4 mapped

                    // Radius decreases as height decreases
                    // h = 4 (Top) -> r = 3.5
                    // h = -3 (Bottom) -> r = 0.2
                    const radius = ((h + 3.5) / 7.5) * 3.5 + 0.1;

                    const angle = Math.random() * Math.PI * 2 + (h * 2); // Twist

                    const x = radius * Math.cos(angle);
                    const z = radius * Math.sin(angle);
                    const y = h;

                    setTarget(i, x, y, z);
                }
            },
            globe: () => {
                // Global Command Center (Geo-Sphere with Hotspots)
                const R = 6;

                // Define hotspots (Lat/Lon in radians)
                // approximating: US (North/West), Europe (North/East), APAC (South/East)
                const hotspots = [
                    { theta: 1.5, phi: 1.2, strength: 0.4 }, // US-ish
                    { theta: 5.0, phi: 1.0, strength: 0.3 }, // Europe-ish
                    { theta: 3.5, phi: 2.2, strength: 0.3 }  // APAC-ish
                ];

                for (let i = 0; i < config.particleCount; i++) {
                    let theta, phi;

                    // 70% of particles form the base sphere (World background)
                    if (Math.random() > 0.3) {
                        phi = Math.acos(-1 + (2 * Math.random()));
                        theta = Math.sqrt(config.particleCount * Math.PI) * phi;
                    } else {
                        // 30% cluster around hotspots (Active Markets)
                        const region = hotspots[Math.floor(Math.random() * hotspots.length)];
                        theta = region.theta + (Math.random() - 0.5) * 0.5;
                        phi = region.phi + (Math.random() - 0.5) * 0.5;
                    }

                    const x = R * Math.cos(theta) * Math.sin(phi);
                    const y = R * Math.sin(theta) * Math.sin(phi);
                    const z = R * Math.cos(phi);
                    setTarget(i, x, y, z);
                }
            },
            journey: () => {
                // Customer Journey Flow (Splines/Curves)
                // Left (-10) to Right (+10) Flow

                // 3 Channels merging into 1
                for (let i = 0; i < config.particleCount; i++) {
                    // We'll define x linearly from left to right
                    // But scatter them a bit for volume
                    const t = Math.random();
                    const x = (t * 20) - 10;

                    // Y determines the 'channel' based on x
                    let y = 0;
                    let z = 0;

                    // Logistic Sigmoid for merging: 1 / (1 + e^-k(x-x0))
                    // Merging happens around x = -2
                    const mergeFactor = 1 / (1 + Math.exp(x + 2)); // High at left, 0 at right

                    // Randomly assign to a branch
                    const branchID = Math.floor(Math.random() * 3);

                    if (branchID === 0) y = 5 * mergeFactor + Math.sin(x) * 0.5; // Top Branch
                    if (branchID === 1) y = 0 + Math.sin(x * 1.2) * 0.5;           // Mid Branch
                    if (branchID === 2) y = -5 * mergeFactor + Math.sin(x * 0.8) * 0.5; // Bot Branch

                    z = (Math.random() - 0.5) * 2; // Thickness

                    setTarget(i, x, y, z);
                }
            },
            fireworks: () => {
                // Burst from center
                for (let i = 0; i < config.particleCount; i++) {
                    // Random direction
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    // Random radius mostly at edge
                    const r = 2 + Math.random() * 8;

                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = r * Math.sin(phi) * Math.sin(theta);
                    const z = r * Math.cos(phi);
                    setTarget(i, x, y, z);
                }
            }
        };

        // Initialize default shape
        shapes[state.currentShape]();

        // --- Interaction & Event Listeners ---
        function switchShape(shapeName) {
            if (shapes[shapeName]) {
                state.currentShape = shapeName;
                shapes[shapeName]();

                // Update UI buttons
                document.querySelectorAll('.tpl-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.shape === shapeName);
                });
            }
        }

        // Click handlers for templates
        document.querySelectorAll('.tpl-btn').forEach(btn => {
            btn.addEventListener('click', () => switchShape(btn.dataset.shape));
        });

        // Help Modal Toggle
        function toggleHelp() {
            const modal = document.getElementById('help-modal');
            modal.classList.toggle('visible');
        }

        // Show help on first load (after minimal delay)
        setTimeout(() => {
            if (!localStorage.getItem('helpShown')) {
                toggleHelp();
                localStorage.setItem('helpShown', 'true');
            }
        }, 2000);

        // Color picker
        const colorPicker = document.getElementById('color-picker');
        colorPicker.addEventListener('input', (e) => {
            state.targetColor.set(e.target.value);
            state.baseColor.set(e.target.value);
            material.color.set(state.targetColor);
        });

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Toggle Video Size
        const videoContainer = document.getElementById('video-container');
        if (videoContainer) {
            videoContainer.addEventListener('click', () => {
                videoContainer.classList.toggle('collapsed');
            });
        }

        // --- Hand Tracking Setup (MediaPipe) ---
        const videoElement = document.getElementById('video-feed');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');


        // Global Cache for Hot Path
        const uiElements = {
            loader: document.getElementById('loader'),
            pinchDot: document.getElementById('pinch-dot'),
            pinchText: document.getElementById('pinch-text'),
            zoomDot: document.getElementById('zoom-dot'),
            zoomText: document.getElementById('zoom-text')
        };

        // Pre-allocated array to avoid GC in loop
        const fpLandmarks = new Array(21).fill(0).map(() => [0, 0, 0]);

        function onResults(results) {
            // Hide loader on first result
            uiElements.loader.classList.add('hidden');

            // Cache UI elements (avoid repeated DOM queries)
            const { pinchDot, pinchText, zoomDot, zoomText } = uiElements;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handDetected = true;
                statusDot.classList.add('active');
                statusText.innerText = `Hands Detected: ${results.multiHandLandmarks.length}`;

                // --- HAND IDENTITY TRACKING ---
                // Use handedness to maintain consistent hand identity and prevent swap issues
                let primaryHandIndex = 0;
                if (results.multiHandedness && results.multiHandedness.length > 0) {
                    const currentLabel = results.multiHandedness[0].label;

                    // If we have a locked primary hand, find it
                    if (state.primaryHandLabel !== null) {
                        for (let i = 0; i < results.multiHandedness.length; i++) {
                            if (results.multiHandedness[i].label === state.primaryHandLabel) {
                                primaryHandIndex = i;
                                break;
                            }
                        }
                    } else if (state.isGrabbing || state.isPinching) {
                        // Lock to current hand when grabbing starts
                        state.primaryHandLabel = currentLabel;
                    }
                }

                const landmarks = results.multiHandLandmarks[primaryHandIndex];
                const wrist = landmarks[0];
                const tips = [4, 8, 12, 16, 20];

                // --- Fingerpose Gesture Detection ---
                // Convert MediaPipe landmarks to Fingerpose format [[x,y,z], ...]
                // Optimized: Fill pre-allocated array
                for (let i = 0; i < landmarks.length; i++) {
                    fpLandmarks[i][0] = landmarks[i].x * 640;
                    fpLandmarks[i][1] = landmarks[i].y * 480;
                    fpLandmarks[i][2] = landmarks[i].z * 100;
                }
                const gestureResult = gestureEstimator.estimate(fpLandmarks, 7.0); // Min confidence 7.0

                // Update gesture scores (smoothed)
                if (gestureResult.gestures && gestureResult.gestures.length > 0) {
                    gestureResult.gestures.forEach(g => {
                        if (state.gestureScores[g.name] !== undefined) {
                            state.gestureScores[g.name] = state.gestureScores[g.name] * 0.7 + g.score * 0.3;
                        }
                    });
                }
                // Decay scores for undetected gestures
                Object.keys(state.gestureScores).forEach(key => {
                    if (!gestureResult.gestures?.find(g => g.name === key)) {
                        state.gestureScores[key] *= 0.85;
                    }
                });

                // Calculate Tension
                let totalDist = 0;
                tips.forEach(idx => {
                    const tip = landmarks[idx];
                    const d = Math.sqrt(
                        Math.pow(tip.x - wrist.x, 2) +
                        Math.pow(tip.y - wrist.y, 2)
                    );
                    totalDist += d;
                });

                const avgDist = totalDist / tips.length;
                const minC = 0.12;
                const maxC = 0.35;
                const normalized = (avgDist - minC) / (maxC - minC);
                let tension = 1 - Math.max(0, Math.min(1, normalized));

                // Boost tension with Fingerpose fist detection
                const fistBoost = state.gestureScores.fist / 10 * 0.3; // Up to 30% boost
                tension = Math.min(1, tension + fistBoost);
                state.tension = state.tension * 0.92 + tension * 0.08;

                // --- Pinch Detection with Hysteresis + Fingerpose ---
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                const pinchMin = 0.04;
                const pinchMax = 0.12;
                const pinchNorm = (pinchDist - pinchMin) / (pinchMax - pinchMin);
                let rawPinchStrength = 1 - Math.max(0, Math.min(1, pinchNorm));

                // Fingerpose as optional boost (not replacement) - keeps original detection working
                const fpPinchBoost = state.gestureScores.pinch / 10 * 0.15; // Up to 15% boost
                rawPinchStrength = Math.min(1, rawPinchStrength + fpPinchBoost);
                state.pinchStrength = state.pinchStrength * 0.85 + rawPinchStrength * 0.15;

                const wasPinching = state.isPinching;
                const wasDoublePinching = state.isDoublePinching;
                const wasSteering = state.isSteering;
                const hadTwoHands = state.twoHandsDetected;

                // Hysteresis: different thresholds for entering vs exiting pinch state
                const rawPinchState = state.isPinching
                    ? state.pinchStrength > config.pinchExitThreshold   // Stay pinching until below exit threshold
                    : state.pinchStrength > config.pinchEnterThreshold; // Only start pinching above enter threshold

                // Debounce the pinch state to prevent rapid toggling
                state.isPinching = debouncers.pinch.update(rawPinchState);

                // --- Grab Point Calculation with Filtering ---
                const rawGrabX = (thumbTip.x + indexTip.x) / 2;
                const rawGrabY = (thumbTip.y + indexTip.y) / 2;

                // Apply One Euro Filter for smooth, responsive tracking
                const grabPointX = filters.hand1.grabX.filter(rawGrabX);
                const grabPointY = filters.hand1.grabY.filter(rawGrabY);
                state.currentHandPos = { x: grabPointX, y: grabPointY };

                // --- TWO-HAND DETECTION ---
                if (results.multiHandLandmarks.length >= 2) {
                    state.twoHandsDetected = true;

                    // Get second hand (the one that's NOT the primary)
                    const secondHandIndex = primaryHandIndex === 0 ? 1 : 0;
                    const hand2 = results.multiHandLandmarks[secondHandIndex];

                    // Fingerpose for second hand
                    const fp2Landmarks = hand2.map(lm => [lm.x * 640, lm.y * 480, lm.z * 100]);
                    const gesture2Result = gestureEstimator.estimate(fp2Landmarks, 7.0);
                    if (gesture2Result.gestures && gesture2Result.gestures.length > 0) {
                        gesture2Result.gestures.forEach(g => {
                            if (state.gestureScores2[g.name] !== undefined) {
                                state.gestureScores2[g.name] = state.gestureScores2[g.name] * 0.7 + g.score * 0.3;
                            }
                        });
                    }
                    Object.keys(state.gestureScores2).forEach(key => {
                        if (!gesture2Result.gestures?.find(g => g.name === key)) {
                            state.gestureScores2[key] *= 0.85;
                        }
                    });

                    const h2Thumb = hand2[4];
                    const h2Index = hand2[8];
                    const h2PinchDist = Math.sqrt(Math.pow(h2Thumb.x - h2Index.x, 2) + Math.pow(h2Thumb.y - h2Index.y, 2));

                    const h2PinchMin = 0.04;
                    const h2PinchMax = 0.12;
                    const h2PinchNorm = (h2PinchDist - h2PinchMin) / (h2PinchMax - h2PinchMin);
                    let h2RawPinchStrength = 1 - Math.max(0, Math.min(1, h2PinchNorm));

                    // Fingerpose as optional boost for hand 2
                    const fp2PinchBoost = state.gestureScores2.pinch / 10 * 0.15;
                    h2RawPinchStrength = Math.min(1, h2RawPinchStrength + fp2PinchBoost);
                    state.hand2PinchStrength = state.hand2PinchStrength * 0.85 + h2RawPinchStrength * 0.15;

                    // Hand 2 pinch with hysteresis and debouncing
                    const rawH2PinchState = state.hand2PinchStrength > config.pinchEnterThreshold;
                    const isHand2Pinching = debouncers.pinch2.update(rawH2PinchState);

                    // --- GESTURE PRIORITY SYSTEM ---
                    // Priority: Namaste Reset > Double Pinch Zoom > Two-Hand Steering > Single-Hand Grab

                    // Filter palm positions for stable steering/zoom
                    const rawPalm1X = landmarks[0].x;
                    const rawPalm1Y = landmarks[0].y;
                    const rawPalm2X = hand2[0].x;
                    const rawPalm2Y = hand2[0].y;

                    const palm1X = filters.hand1.palmX.filter(rawPalm1X);
                    const palm1Y = filters.hand1.palmY.filter(rawPalm1Y);
                    const palm2X = filters.hand2.palmX.filter(rawPalm2X);
                    const palm2Y = filters.hand2.palmY.filter(rawPalm2Y);

                    const palm1 = { x: palm1X, y: palm1Y };
                    const palm2 = { x: palm2X, y: palm2Y };
                    const palmDist = Math.sqrt(Math.pow(palm1.x - palm2.x, 2) + Math.pow(palm1.y - palm2.y, 2));
                    const handDist = palmDist;
                    state.twoHandDistance = handDist;

                    // --- NAMASTE RESET (Priority 1 - Highest) ---
                    // Use RAW positions for Namaste (filters add lag)
                    const rawPalmDist = Math.sqrt(
                        Math.pow(rawPalm1X - rawPalm2X, 2) +
                        Math.pow(rawPalm1Y - rawPalm2Y, 2)
                    );

                    const now = performance.now();
                    const inCooldown = now < state.namasteCooldownUntil;
                    const namasteThreshold = 0.28;

                    if (rawPalmDist < namasteThreshold && !inCooldown) {
                        // TRIGGER RESET
                        state.objectOffset = { x: 0, y: 0, z: 0 };
                        state.objectRotation = { x: 0, y: 0, z: 0 };
                        state.twoHandScale = 1.0;
                        state.neutralDistance = null;
                        state.isGrabbing = false;
                        state.isDoublePinching = false;
                        state.isSteering = false;
                        state.twoHandStartAngle = null;
                        state.primaryHandLabel = null;

                        // Reset momentum
                        state.momentumActive = false;
                        state.velocity = { x: 0, y: 0 };
                        state.angularVelocity = 0;

                        // Set 500ms cooldown to prevent re-triggers
                        state.namasteCooldownUntil = now + 500;

                        // Reset all filters and debouncers for clean state
                        Object.values(filters.hand1).forEach(f => f.reset());
                        Object.values(filters.hand2).forEach(f => f.reset());
                        Object.values(debouncers).forEach(d => d.reset());

                        zoomText.innerText = "Reset!";
                        zoomDot.classList.add('active');
                        pinchDot.classList.remove('active');
                        pinchText.innerText = 'Namaste Reset';
                        return;
                    }

                    // --- DOUBLE PINCH ZOOM (Priority 2) ---
                    if (state.isPinching && isHand2Pinching) {
                        state.isDoublePinching = true;
                        state.isGrabbing = false;
                        state.isSteering = false;
                        state.twoHandStartAngle = null;

                        if (state.neutralDistance === null) {
                            state.neutralDistance = handDist;
                            zoomText.innerText = `Zoom Locked: Stretch/Compress`;
                        } else {
                            const ratio = handDist / state.neutralDistance;
                            let zoomSpeed = 0;

                            if (ratio > 1.1) {
                                zoomSpeed = (ratio - 1.1) * 0.05;
                                zoomText.innerText = `Zooming IN >> ${(state.twoHandScale * 100).toFixed(0)}%`;
                            } else if (ratio < 0.9) {
                                zoomSpeed = (ratio - 0.9) * 0.05;
                                zoomText.innerText = `Zooming OUT << ${(state.twoHandScale * 100).toFixed(0)}%`;
                            } else {
                                zoomText.innerText = `Zoom: ${(state.twoHandScale * 100).toFixed(0)}%`;
                            }

                            state.twoHandScale += zoomSpeed * state.twoHandScale;
                            state.twoHandScale = Math.max(0.1, Math.min(50.0, state.twoHandScale));
                        }

                        zoomDot.classList.add('active');
                        pinchDot.classList.add('active');
                        pinchText.innerText = 'Double Pinch Zoom';

                        // --- TWO-HAND STEERING (Priority 3) ---
                        // Activate when: exactly ONE hand is pinching (XOR condition)
                    } else if ((state.isPinching !== isHand2Pinching) && palmDist > 0.25) {
                        state.isDoublePinching = false;
                        state.neutralDistance = null;
                        state.isSteering = true;
                        state.isGrabbing = false; // CRITICAL: Disable grab rotation conflict

                        const angle = Math.atan2(palm2.y - palm1.y, palm2.x - palm1.x);

                        if (state.twoHandStartAngle === null || !wasSteering) {
                            state.twoHandStartAngle = angle;
                            state.twoHandStartObjRotation = state.objectRotation.z;
                        } else {
                            const deltaAngle = angle - state.twoHandStartAngle;
                            state.objectRotation.z = state.twoHandStartObjRotation - deltaAngle;
                        }

                        zoomDot.classList.add('active');
                        zoomText.innerText = 'Steering Mode';
                        pinchDot.classList.add('active');
                        pinchText.innerText = 'Steering...';

                    } else {
                        // No two-hand gesture active
                        state.isDoublePinching = false;
                        state.neutralDistance = null;
                        state.isSteering = false;
                        state.twoHandStartAngle = null;
                        zoomDot.classList.remove('active');
                        zoomText.innerText = 'Pinch both hands to zoom';
                    }

                } else {
                    // --- SINGLE HAND MODE ---
                    const wasInTwoHandMode = hadTwoHands;
                    state.twoHandsDetected = false;
                    state.isDoublePinching = false;
                    state.isSteering = false;
                    state.twoHandStartAngle = null;
                    state.neutralDistance = null;
                    state.hand2PinchStrength = state.hand2PinchStrength * 0.9;

                    zoomDot.classList.remove('active');
                    zoomText.innerText = 'Add second hand for zoom';

                    // --- RE-INITIALIZE GRAB after returning from two-hand mode ---
                    // This fixes the "sudden jump" bug when transitioning
                    if (wasInTwoHandMode && state.isPinching) {
                        state.isGrabbing = true;
                        state.grabStartHandPos = { x: grabPointX, y: grabPointY };
                        state.grabStartObjectPos = {
                            x: state.objectOffset.x,
                            y: state.objectOffset.y,
                            z: state.objectOffset.z
                        };
                        const indexMCP = landmarks[5];
                        state.grabStartHandAngle = Math.atan2(indexMCP.y - wrist.y, indexMCP.x - wrist.x);
                        state.grabStartObjectRotation = {
                            x: state.objectRotation.x,
                            y: state.objectRotation.y,
                            z: state.objectRotation.z
                        };
                    }
                }

                // --- SINGLE-HAND GRAB-AND-DRAG (Priority 4 - Lowest) ---
                // Only runs when NOT in any two-hand mode
                if (!state.isSteering && !state.isDoublePinching) {

                    // Pinch just started - initialize grab
                    if (state.isPinching && !wasPinching) {
                        state.isGrabbing = true;
                        state.grabStartHandPos = { x: grabPointX, y: grabPointY };
                        state.grabStartObjectPos = {
                            x: state.objectOffset.x,
                            y: state.objectOffset.y,
                            z: state.objectOffset.z
                        };
                        const indexMCP = landmarks[5];
                        state.grabStartHandAngle = Math.atan2(indexMCP.y - wrist.y, indexMCP.x - wrist.x);
                        state.grabStartObjectRotation = {
                            x: state.objectRotation.x,
                            y: state.objectRotation.y,
                            z: state.objectRotation.z
                        };

                        // Lock hand identity
                        if (results.multiHandedness && results.multiHandedness.length > 0) {
                            state.primaryHandLabel = results.multiHandedness[primaryHandIndex].label;
                        }

                        // Initialize momentum tracking
                        state.velocity = { x: 0, y: 0 };
                        state.angularVelocity = 0;
                        state.lastGrabPos = { x: state.objectOffset.x, y: state.objectOffset.y };
                        state.lastGrabAngle = state.objectRotation.z;
                        state.momentumActive = false;
                    }

                    // While grabbing - apply translation and rotation
                    if (state.isGrabbing && state.isPinching) {
                        const sensitivity = 25;
                        const deltaX = (grabPointX - state.grabStartHandPos.x) * sensitivity;
                        const deltaY = -(grabPointY - state.grabStartHandPos.y) * sensitivity;

                        state.objectOffset.x = state.grabStartObjectPos.x - deltaX;
                        state.objectOffset.y = state.grabStartObjectPos.y + deltaY;

                        // Only apply rotation if NOT steering (prevent conflict)
                        if (!state.twoHandsDetected) {
                            const indexMCP = landmarks[5];
                            const currentHandAngle = Math.atan2(indexMCP.y - wrist.y, indexMCP.x - wrist.x);
                            const deltaAngle = currentHandAngle - state.grabStartHandAngle;
                            state.objectRotation.z = state.grabStartObjectRotation.z - deltaAngle;
                        }

                        // Track velocity for momentum (position + rotation)
                        const dx = state.objectOffset.x - state.lastGrabPos.x;
                        const dy = state.objectOffset.y - state.lastGrabPos.y;
                        state.velocity.x = state.velocity.x * 0.7 + dx * 0.3;
                        state.velocity.y = state.velocity.y * 0.7 + dy * 0.3;
                        state.lastGrabPos.x = state.objectOffset.x;
                        state.lastGrabPos.y = state.objectOffset.y;

                        const dAngle = state.objectRotation.z - state.lastGrabAngle;
                        state.angularVelocity = state.angularVelocity * 0.7 + dAngle * 0.3;
                        state.lastGrabAngle = state.objectRotation.z;

                        pinchDot.classList.add('active');
                        pinchText.innerText = 'Grabbing...';
                    }

                    // Pinch released
                    if (!state.isPinching && wasPinching) {
                        state.isGrabbing = false;
                        state.momentumActive = true; // Enable momentum continuation
                        state.primaryHandLabel = null; // Release hand lock
                    }
                }

                // Update UI for non-grabbing pinch state
                if (!state.isGrabbing && !state.isSteering && !state.isDoublePinching) {
                    if (state.isPinching) {
                        pinchDot.classList.add('active');
                        pinchText.innerText = 'Pinch: Active ‚úì';
                    } else {
                        pinchDot.classList.remove('active');
                        // Show pinch strength vs threshold for debugging
                        pinchText.innerText = `Pinch: ${Math.round(state.pinchStrength * 100)}% (need >${Math.round(config.pinchEnterThreshold * 100)}%)`;
                    }
                }

            } else {
                // --- NO HANDS DETECTED ---
                state.handDetected = false;
                state.twoHandsDetected = false;
                statusDot.classList.remove('active');
                statusText.innerText = "No Hands Detected";

                // Gradual decay
                state.tension = state.tension * 0.985;
                state.pinchStrength = state.pinchStrength * 0.95;
                state.hand2PinchStrength = state.hand2PinchStrength * 0.95;

                // Reset all gesture states
                state.isPinching = false;
                state.isGrabbing = false;
                state.isZooming = false;
                state.isSteering = false;
                state.isDoublePinching = false;
                state.twoHandStartAngle = null;
                state.neutralDistance = null;
                state.primaryHandLabel = null;

                // Reset filters and debouncers when hands are lost
                Object.values(filters.hand1).forEach(f => f.reset());
                Object.values(filters.hand2).forEach(f => f.reset());
                Object.values(debouncers).forEach(d => d.reset());

                pinchDot.classList.remove('active');
                pinchText.innerText = 'Pinch: Inactive';
                zoomDot.classList.remove('active');
                zoomText.innerText = 'Show hands to begin';
            }
        }

        // --- Face Mesh Setup ---
        const faceMesh = new FaceMesh({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            }
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        faceMesh.onResults((results) => {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                const nose = landmarks[1]; // Index 1 is nose tip

                // Calculate parallax offset (inverted for window effect)
                const targetX = (nose.x - 0.5) * 4;
                const targetY = (nose.y - 0.5) * 2;

                state.parallax.targetX = targetX;
                state.parallax.targetY = targetY;
            }
        });

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Webcam initialization
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });

        cameraUtils.start()
            .then(() => console.log('Camera started'))
            .catch(err => {
                console.error('Camera error', err);
                statusText.innerText = "Camera Access Denied";
                document.getElementById('loader').classList.add('hidden');
            });


        // --- FPS Monitoring ---
        let frameCount = 0;
        let lastTimeFps = performance.now();
        let activeParticleCount = config.particleCount;

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Parallax Smoothing (Lerp)
            state.parallax.x += (state.parallax.targetX - state.parallax.x) * 0.05;
            state.parallax.y += (state.parallax.targetY - state.parallax.y) * 0.05;

            // Apply Parallax to Camera
            camera.position.x += (state.parallax.x * 0.1 - camera.position.x) * 0.1;
            camera.position.y += (state.parallax.y * 0.1 + 2 - camera.position.y) * 0.1; // +2 base offset

            // FPS Counter & Optimization
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTimeFps >= 1000) {
                const fps = frameCount;
                document.getElementById('fps-counter').innerText = `FPS: ${fps}`;

                frameCount = 0;
                lastTimeFps = currentTime;
            }

            const positionAttribute = geometry.attributes.position;
            const currentPositions = positionAttribute.array;

            // Time for idle animation
            state.time += 0.01;

            // Determine Scale Factor based on Hand Tension
            // High tension (fist) = Contract/Small or Explode? 
            // Requirements: "detect tension... Map this to: Scaling... Expansion/contraction"
            // Let's make High Tension = Expansion (Power up) or Contraction (Crush).
            // Let's go with: Open Hand = Relaxed (Normal Size), Closed Hand = High Tension (Particles contract tightly and shake)

            // Actually, usually "Opening hand" feels like expansion.
            // Let's do: Closed Fist = Contract/condense to center. Open Hand = Expand beyond normal.

            // Base scale is 1.0
            // Tension 1.0 (Closed) -> Scale 0.5
            // Tension 0.0 (Open) -> Scale 1.5
            // But if hands not detected, default to 1.0 idle breathing

            let targetScaleFactor = 1.0;
            if (state.handDetected) {
                // Map tension (0..1) to scale
                // Tension 0 (Open) -> 1.5
                // Tension 1 (Closed) -> 0.4
                targetScaleFactor = 1.5 - (state.tension * 1.1);
            } else {
                // Idle breathing
                targetScaleFactor = 1.0 + Math.sin(state.time) * 0.1;
            }
            // Smooth transition to target scale factor (prevents sudden jumps)
            state.lastScaleFactor += (targetScaleFactor - state.lastScaleFactor) * 0.08;
            const scaleFactor = state.lastScaleFactor;

            // Loop through particles
            for (let i = 0; i < config.particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                // 1. Interpolate towards target shape
                const tx = targetPositions[ix];
                const ty = targetPositions[iy];
                const tz = targetPositions[iz];

                // Lerp current to target
                currentPositions[ix] += (tx - currentPositions[ix]) * config.lerpSpeed;
                currentPositions[iy] += (ty - currentPositions[iy]) * config.lerpSpeed;
                currentPositions[iz] += (tz - currentPositions[iz]) * config.lerpSpeed;

                // 2. Apply Interaction (Scale/Explode based on tension)
                // We modify the rendered position relative to center (0,0,0) or center of mass?
                // Simple scaling around (0,0,0)

                // We don't overwrite the buffer 'currentPositions' with the scaled version permanently, 
                // otherwise it drifts. We apply the scale to the coordinate we write back, 
                // BUT we need 'currentPositions' to store the shape state.

                // Solution: We update 'currentPositions' to move towards 'targetPositions'. 
                // BUT, to render the scale effect, we might need to update the actual geometry 
                // differently or apply a global scale to the Object3D.

                // Applying global scale to the Points object is most efficient and smooth.
                // However, the requirement says "Map tension to... Scaling of the entire particle group".
                // Yes, valid.
            }

            // Update Geometry
            positionAttribute.needsUpdate = true;

            // Apply Scale & Rotation

            // Apply momentum after release (position + rotation)
            if (state.momentumActive && !state.isGrabbing) {
                // Apply velocity to position
                state.objectOffset.x += state.velocity.x;
                state.objectOffset.y += state.velocity.y;

                // Apply angular velocity to rotation
                state.objectRotation.z += state.angularVelocity;

                // Exponential decay (friction = 0.92)
                const friction = 0.92;
                state.velocity.x *= friction;
                state.velocity.y *= friction;
                state.angularVelocity *= friction;

                // Stop momentum when all velocities are negligible
                const speed = Math.sqrt(state.velocity.x ** 2 + state.velocity.y ** 2);
                const angSpeed = Math.abs(state.angularVelocity);
                if (speed < 0.001 && angSpeed < 0.0001) {
                    state.momentumActive = false;
                    state.velocity = { x: 0, y: 0 };
                    state.angularVelocity = 0;
                }
            }

            // Auto-rotate ONLY if not grabbing (and not in momentum)
            if (!state.isGrabbing && !state.momentumActive) {
                state.objectRotation.y += 0.002;
            }

            // Apply proper rotations from state
            // Lerp towards the state rotation for smoothness
            // We use a simple lerp on Euler angles (works fine for small increments)
            particles.rotation.x = state.objectRotation.x;
            particles.rotation.y = state.objectRotation.y;
            particles.rotation.z = state.objectRotation.z;

            // Smoothly interpolate the object scale (0.05 for very smooth transitions)
            // Priority: Two-handed zoom > Grab (Stable) > Single-hand tension > Idle
            let finalScale = scaleFactor;

            if (state.twoHandsDetected) {
                // Iron Man Zoom
                finalScale = state.twoHandScale;
            } else if (state.isGrabbing) {
                // STABLE GRAB: When holding the object, keep it at a stable size
                // We use the last known zoom scale (or default 1.0) so it doesn't shrink
                finalScale = Math.max(state.twoHandScale, 1.0);
            }
            // Else fall back to 'scaleFactor' (Textion/Idle)

            particles.scale.lerp(new THREE.Vector3(finalScale, finalScale, finalScale), 0.08);

            // --- Color Logic with Visual Feedback ---
            let targetColor = state.baseColor.clone();

            // DATA DRIVEN COLORING (New)
            // Override base color if in specific data modes
            if (state.currentShape === 'funnel') {
                // Gradient based on Height (Y)
                // We need access to the particle's target Y or current Y.
                // Since this loop is per-frame global, we can't easily color per-particle HERE 
                // unless we use a Shader or Vertex Colors.
                // Three.js PointsMaterial 'color' is global.
                // To do per-particle colors, we need to switch to Vertex Colors.

                // For this demo (MVP), we will shift the GLOBAL color based on interaction
                // OR we can't do per-node color without BufferGeometry attribute updates.

                // DECISION: To keep it simple/performant: 
                // We stick to Global Color shifting for now.
                // Funnel: Shifts to Gold when "grabbing" (Reaching revenue).

                if (state.isGrabbing) {
                    targetColor.setHex(0xffd700); // Gold (Revenue)
                } else {
                    targetColor.setHex(0x00f3ff); // Cyan (Leads)
                }

            } else if (state.currentShape === 'globe') {
                if (state.isGrabbing) {
                    targetColor.setHex(0x00ff88); // Green (Global Growth)
                }
            }

            // Standard Interactions (overrides only if not set above or mixing)
            // Color shift during grab (warmer tint)
            if (state.isGrabbing && state.currentShape !== 'funnel') {
                const grabTint = new THREE.Color(0xffaa44); // Warm orange
                targetColor.lerp(grabTint, 0.3);
            }

            // Brighter during zoom
            if (state.isDoublePinching) {
                const zoomTint = new THREE.Color(0xffffff); // White boost
                targetColor.lerp(zoomTint, 0.2);
            }

            // Slight red shift during high tension
            if (state.tension > 0.7 && !state.isGrabbing) {
                const tensionTint = new THREE.Color(0xff6666); // Reddish
                targetColor.lerp(tensionTint, (state.tension - 0.7) * 1.5);
            }

            material.color.lerp(targetColor, 0.1);

            // --- Apply Grab Offset (Pinch-and-Drag) ---
            // Smoothly lerp the particle group position towards the target offset
            const targetX = state.objectOffset.x;
            const targetY = state.objectOffset.y;

            // Add jitter if high tension (but not when grabbing)
            let jitterX = 0, jitterY = 0;
            if (state.tension > 0.7 && !state.isGrabbing) {
                // Intensity scales with tension (0.7-1.0 ‚Üí 0-1)
                const intensity = (state.tension - 0.7) / 0.3;
                jitterX = (Math.random() - 0.5) * 0.4 * intensity;
                jitterY = (Math.random() - 0.5) * 0.4 * intensity;
            }

            // Smooth position update
            particles.position.x += ((targetX + jitterX) - particles.position.x) * 0.1;
            particles.position.y += ((targetY + jitterY) - particles.position.y) * 0.1;

            // --- Particle Size Effects ---
            let targetSize = config.baseSize;

            // Glow effect during zoom (larger particles)
            if (state.isDoublePinching) {
                targetSize = config.baseSize * 1.4;
            }

            // Pulse effect during high tension
            if (state.tension > 0.7 && !state.isGrabbing) {
                const pulse = Math.sin(state.time * 15) * 0.03 * ((state.tension - 0.7) / 0.3);
                targetSize += pulse;
            }

            // Smooth size transition
            material.size += (targetSize - material.size) * 0.1;

            // --- Data Tooltip Logic ---
            const tooltip = document.getElementById('data-tooltip');
            const ttTitle = document.getElementById('tt-title');
            const ttValue = document.getElementById('tt-value');

            // Show tooltip when interacting (Grabbing)
            if (state.isGrabbing) {
                // Get 2D Screen Position of the Object Center (roughly)
                // We use the last grab position (screen space? No, 3D space)
                const vector = new THREE.Vector3(state.objectOffset.x, state.objectOffset.y, state.objectOffset.z);

                // Project 3D vector to 2D screen
                vector.project(camera);

                const x = (vector.x * .5 + .5) * window.innerWidth;
                const y = (-(vector.y * .5) + .5) * window.innerHeight;

                tooltip.style.display = 'block';
                tooltip.style.left = `${x}px`;
                tooltip.style.top = `${y}px`;

                // Update Content based on Mode (Dynamic Data from Phase 8)
                if (state.currentShape === 'funnel') {
                    ttTitle.innerText = "Revenue Forecast";
                    ttValue.innerText = `Forecast: $${state.data.revenue.forecast}`;
                    tooltip.style.borderColor = "#ffd700"; // Gold
                } else if (state.currentShape === 'globe') {
                    ttTitle.innerText = "APAC Growth";
                    ttValue.innerText = `Growth: +${state.data.regions.apac.growth}% YoY`;
                    tooltip.style.borderColor = "#00ff88"; // Green
                } else if (state.currentShape === 'journey') {
                    ttTitle.innerText = "Conversion Rate";
                    ttValue.innerText = `Funnel: ${state.data.funnel.conversion_rate}% (Avg)`;
                    tooltip.style.borderColor = "#00f3ff"; // Cyan
                } else {
                    ttTitle.innerText = "System Status";
                    ttValue.innerText = "Particles: " + activeParticleCount;
                    tooltip.style.borderColor = "#00f3ff";
                }
            } else {
                tooltip.style.display = 'none';
            }

            renderer.render(scene, camera);
        }

        animate();

        // --- Keyboard Controls ---
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                // RESET (Same as Namaste)
                state.objectOffset = { x: 0, y: 0, z: 0 };
                state.objectRotation = { x: 0, y: 0, z: 0 };
                state.twoHandScale = 1.0;
                state.neutralDistance = null;
                state.isGrabbing = false;
                state.isDoublePinching = false;

                const zoomText = document.getElementById('status-text');
                if (zoomText) zoomText.innerText = "System Reset";
            }
        });

    </script>
</body>

</html>